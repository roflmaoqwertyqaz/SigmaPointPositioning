function [apriori_state,apriori_measurement, propagated_states, propagated_measurements] ...
    = propagate_and_combine_sigma_points(sigma_points, forward_input, turn_input, dt)
    propagated_measurements = zeros(SigmaPointConstants.nm, SigmaPointConstants.ns);
    propagated_states = zeros(SigmaPointConstants.nx, SigmaPointConstants.ns);
    for sp = 1:SigmaPointConstants.ns
        [state, encoder] = drivetrain_transform(sigma_points(1:SigmaPointConstants.nx, sp)',  ...
            forward_input, turn_input, dt, ...
            sigma_points(SigmaPointConstants.nx+1, sp), ...
            sigma_points(SigmaPointConstants.nx+2, sp));
        propagated_states(:,sp) = state';
        
        propagated_measurements(1:2, sp) = encoder';
        imu_data = sim_imu(state, ...
            sigma_points(SigmaPointConstants.nm+3:SigmaPointConstants.nm+5, sp)', [0 0 0]);
        propagated_measurements(3:5, sp) = imu_data';
        
        rangefinder_data = sim_rangefinders(state, ...
            sigma_points(SigmaPointConstants.nm+6:SigmaPointConstants.nm+8, sp)', [0 0 0], ...
            SigmaPointConstants.rangefinder_angle_offset);
        propagated_measurements(6:8, sp) = rangefinder_data';
    end
    apriori_state = SigmaPointConstants.W_m_0 * propagated_states(:,1) + ...
        SigmaPointConstants.W_i * sum(propagated_states(:, 2:end), 2);
    apriori_measurement = SigmaPointConstants.W_m_0 * propagated_measurements(:,1) + ...
        SigmaPointConstants.W_i * sum(propagated_measurements(:, 2:end), 2);
end

